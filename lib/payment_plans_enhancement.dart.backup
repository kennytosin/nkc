import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:intl/intl.dart';
import 'package:http/http.dart' as http;
import 'dart:convert';
import 'dart:io' show Platform;
import 'paystack_service.dart';

// ------------------------- CURRENCY MODELS -------------------------

enum Currency {
  NGN, // Nigerian Naira
  USD, // US Dollar
  GBP, // British Pound
  EUR, // Euro
  GHS, // Ghanaian Cedi
  KES, // Kenyan Shilling
  ZAR, // South African Rand
}

extension CurrencyExtension on Currency {
  String get symbol {
    switch (this) {
      case Currency.NGN:
        return '‚Ç¶';
      case Currency.USD:
        return '\$';
      case Currency.GBP:
        return '¬£';
      case Currency.EUR:
        return '‚Ç¨';
      case Currency.GHS:
        return 'GH‚Çµ';
      case Currency.KES:
        return 'KSh';
      case Currency.ZAR:
        return 'R';
    }
  }

  String get code {
    return name;
  }
}

// ------------------------- SUBSCRIPTION MODELS -------------------------

enum SubscriptionTier { free, threeMonths, sixMonths, yearly }

class SubscriptionPlan {
  final SubscriptionTier tier;
  final String name;
  final Map<Currency, double> prices; // Multiple currency support
  final int durationMonths;
  final List<String> features;
  final List<String> limitations;

  const SubscriptionPlan({
    required this.tier,
    required this.name,
    required this.prices,
    required this.durationMonths,
    required this.features,
    required this.limitations,
  });

  // Get price for a specific currency
  double getPrice(Currency currency) {
    return prices[currency] ?? prices[Currency.NGN] ?? 0.0;
  }

  static const List<SubscriptionPlan> allPlans = [
    SubscriptionPlan(
      tier: SubscriptionTier.free,
      name: 'Free Plan',
      prices: {
        Currency.NGN: 0.00,
        Currency.USD: 0.00,
        Currency.GBP: 0.00,
        Currency.EUR: 0.00,
        Currency.GHS: 0.00,
        Currency.KES: 0.00,
        Currency.ZAR: 0.00,
      },
      durationMonths: 0,
      features: [
        'Sunday devotionals access',
        'ASV Bible translation only',
        'Basic Bible reading features',
        'Search functionality',
      ],
      limitations: [
        '‚ùå No offline devotional downloads',
        '‚ùå Limited to Sunday devotionals only',
        '‚ùå Only one Bible translation (ASV)',
        '‚ùå No access to weekday devotionals',
      ],
    ),
    SubscriptionPlan(
      tier: SubscriptionTier.threeMonths,
      name: '3-Month Premium',
      prices: {
        Currency.NGN: 1000.00,  // ‚Ç¶1,000
        Currency.USD: 3.00,     // $3
        Currency.GBP: 2.50,     // ¬£2.50
        Currency.EUR: 2.80,     // ‚Ç¨2.80
        Currency.GHS: 40.00,    // GH‚Çµ40
        Currency.KES: 400.00,   // KSh400
        Currency.ZAR: 50.00,    // R50
      },
      durationMonths: 3,
      features: [
        '‚úÖ Access to ALL devotionals',
        '‚úÖ Offline devotional downloads',
        '‚úÖ All Bible translations',
        '‚úÖ Priority support',
        '‚úÖ Ad-free experience',
      ],
      limitations: [],
    ),
    SubscriptionPlan(
      tier: SubscriptionTier.sixMonths,
      name: '6-Month Premium',
      prices: {
        Currency.NGN: 1500.00,  // ‚Ç¶1,500
        Currency.USD: 4.50,     // $4.50
        Currency.GBP: 3.50,     // ¬£3.50
        Currency.EUR: 4.00,     // ‚Ç¨4
        Currency.GHS: 60.00,    // GH‚Çµ60
        Currency.KES: 600.00,   // KSh600
        Currency.ZAR: 75.00,    // R75
      },
      durationMonths: 6,
      features: [
        '‚úÖ Access to ALL devotionals',
        '‚úÖ Offline devotional downloads',
        '‚úÖ All Bible translations',
        '‚úÖ Priority support',
        '‚úÖ Ad-free experience',
        'üíé Best value per month',
      ],
      limitations: [],
    ),
    SubscriptionPlan(
      tier: SubscriptionTier.yearly,
      name: 'Yearly Premium',
      prices: {
        Currency.NGN: 2500.00,  // ‚Ç¶2,500
        Currency.USD: 7.00,     // $7
        Currency.GBP: 5.50,     // ¬£5.50
        Currency.EUR: 6.50,     // ‚Ç¨6.50
        Currency.GHS: 95.00,    // GH‚Çµ95
        Currency.KES: 950.00,   // KSh950
        Currency.ZAR: 120.00,   // R120
      },
      durationMonths: 12,
      features: [
        '‚úÖ Access to ALL devotionals',
        '‚úÖ Offline devotional downloads',
        '‚úÖ All Bible translations',
        '‚úÖ Priority support',
        '‚úÖ Ad-free experience',
        'üíé Maximum savings',
        'üéÅ Bonus features',
      ],
      limitations: [],
    ),
  ];

  // Get formatted price display for a specific currency
  String getPriceDisplay(Currency currency) {
    final price = getPrice(currency);
    if (price == 0) return 'Free';

    // Format based on currency
    switch (currency) {
      case Currency.NGN:
      case Currency.GHS:
      case Currency.KES:
      case Currency.ZAR:
        // No decimal places for these currencies
        return '${currency.symbol}${price.toStringAsFixed(0)}';
      default:
        // 2 decimal places for USD, GBP, EUR
        return '${currency.symbol}${price.toStringAsFixed(2)}';
    }
  }

  String get durationDisplay {
    if (durationMonths == 0) return 'Forever';
    if (durationMonths == 3) return '3 Months';
    if (durationMonths == 6) return '6 Months';
    if (durationMonths == 12) return '1 Year';
    return '$durationMonths Months';
  }

  // Get price per month for a specific currency
  double getPricePerMonth(Currency currency) {
    final price = getPrice(currency);
    return durationMonths == 0 ? 0 : price / durationMonths;
  }
}

// ------------------------- CURRENCY MANAGER -------------------------

class CurrencyManager {
  static const String _currencyKey = 'user_preferred_currency';

  // Detect currency based on device locale
  static Future<Currency> detectCurrency() async {
    try {
      // Try to get from saved preference first
      final saved = await getSavedCurrency();
      if (saved != null) return saved;

      // Detect from device locale
      final String locale = Platform.localeName; // e.g., "en_US", "en_NG"
      final String countryCode = locale.split('_').last.toUpperCase();

      Currency detected;
      switch (countryCode) {
        case 'NG': // Nigeria
          detected = Currency.NGN;
          break;
        case 'US': // United States
          detected = Currency.USD;
          break;
        case 'GB': // United Kingdom
          detected = Currency.GBP;
          break;
        case 'GH': // Ghana
          detected = Currency.GHS;
          break;
        case 'KE': // Kenya
          detected = Currency.KES;
          break;
        case 'ZA': // South Africa
          detected = Currency.ZAR;
          break;
        // European countries
        case 'DE': // Germany
        case 'FR': // France
        case 'IT': // Italy
        case 'ES': // Spain
        case 'NL': // Netherlands
          detected = Currency.EUR;
          break;
        default:
          // Default to USD for unrecognized regions
          detected = Currency.USD;
      }

      // Save the detected currency
      await saveCurrency(detected);
      print('üí± Currency detected: ${detected.code} (${detected.symbol})');
      return detected;
    } catch (e) {
      print('‚ö†Ô∏è Error detecting currency: $e');
      // Fallback to NGN (your primary market)
      return Currency.NGN;
    }
  }

  // Save user's currency preference
  static Future<void> saveCurrency(Currency currency) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_currencyKey, currency.name);
  }

  // Get saved currency preference
  static Future<Currency?> getSavedCurrency() async {
    final prefs = await SharedPreferences.getInstance();
    final saved = prefs.getString(_currencyKey);
    if (saved == null) return null;

    try {
      return Currency.values.firstWhere((c) => c.name == saved);
    } catch (e) {
      return null;
    }
  }

  // Allow users to manually change currency
  static Future<void> changeCurrency(Currency currency) async {
    await saveCurrency(currency);
    print('üí± Currency changed to: ${currency.code}');
  }

  // Get current currency (with fallback)
  static Future<Currency> getCurrentCurrency() async {
    return await detectCurrency();
  }
}

// ------------------------- SUBSCRIPTION MANAGER -------------------------

class SubscriptionManager {
  static const String _tierKeySuffix = '_subscription_tier';
  static const String _expiryKeySuffix = '_subscription_expiry';
  static const String _purchaseDateKeySuffix = '_subscription_purchase_date';

  // Get user-specific keys
  static Future<String> _getUserId() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getString('user_id') ?? 'default_user';
  }

  static Future<String> _getTierKey() async {
    final userId = await _getUserId();
    return '${userId}$_tierKeySuffix';
  }

  static Future<String> _getExpiryKey() async {
    final userId = await _getUserId();
    return '${userId}$_expiryKeySuffix';
  }

  static Future<String> _getPurchaseDateKey() async {
    final userId = await _getUserId();
    return '${userId}$_purchaseDateKeySuffix';
  }

  // Check if user has premium access
  static Future<bool> hasPremiumAccess() async {
    final prefs = await SharedPreferences.getInstance();
    final tierKey = await _getTierKey();
    final tierIndex = prefs.getInt(tierKey) ?? 0;

    if (tierIndex == 0) return false; // Free tier

    final expiryKey = await _getExpiryKey();
    final expiryString = prefs.getString(expiryKey);
    if (expiryString == null) return false;

    final expiryDate = DateTime.parse(expiryString);
    return DateTime.now().isBefore(expiryDate);
  }

  // Get current subscription tier
  static Future<SubscriptionTier> getCurrentTier() async {
    final hasPremium = await hasPremiumAccess();
    if (!hasPremium) return SubscriptionTier.free;

    final prefs = await SharedPreferences.getInstance();
    final tierKey = await _getTierKey();
    final tierIndex = prefs.getInt(tierKey) ?? 0;
    return SubscriptionTier.values[tierIndex];
  }

  // Get subscription expiry date
  static Future<DateTime?> getExpiryDate() async {
    final prefs = await SharedPreferences.getInstance();
    final expiryKey = await _getExpiryKey();
    final expiryString = prefs.getString(expiryKey);
    return expiryString != null ? DateTime.parse(expiryString) : null;
  }

  // Get purchase date
  static Future<DateTime?> getPurchaseDate() async {
    final prefs = await SharedPreferences.getInstance();
    final purchaseDateKey = await _getPurchaseDateKey();
    final purchaseString = prefs.getString(purchaseDateKey);
    return purchaseString != null ? DateTime.parse(purchaseString) : null;
  }

  // Activate subscription
  static Future<void> activateSubscription(SubscriptionPlan plan) async {
    final prefs = await SharedPreferences.getInstance();
    final now = DateTime.now();

    final tierKey = await _getTierKey();
    final expiryKey = await _getExpiryKey();
    final purchaseDateKey = await _getPurchaseDateKey();

    // Check if there's an existing active subscription
    final existingExpiryString = prefs.getString(expiryKey);
    DateTime expiry;
    bool isExtension = false;

    if (existingExpiryString != null) {
      final existingExpiry = DateTime.parse(existingExpiryString);

      // If existing subscription is still active, extend it
      if (existingExpiry.isAfter(now)) {
        // Add new duration to existing expiry date
        expiry = existingExpiry.add(Duration(days: plan.durationMonths * 30));
        isExtension = true;
        print('üìÖ Extending existing subscription');
        print('   Previous expiry: ${existingExpiry.toString().split(' ')[0]}');
      } else {
        // Existing subscription expired, start fresh from now
        expiry = now.add(Duration(days: plan.durationMonths * 30));
      }
    } else {
      // No existing subscription, start from now
      expiry = now.add(Duration(days: plan.durationMonths * 30));
    }

    await prefs.setInt(tierKey, plan.tier.index);
    await prefs.setString(expiryKey, expiry.toIso8601String());
    await prefs.setString(purchaseDateKey, now.toIso8601String());

    final userId = await _getUserId();
    print('‚úÖ Subscription activated for user: $userId');
    print('   Tier: ${plan.name}');
    print(
      '   ${isExtension ? "Extended" : "New"} expiry: ${expiry.toString().split(' ')[0]}',
    );

    // Sync to cloud for cross-device access
    await _syncToSupabase();
  }

  // Cancel subscription (revert to free)
  static Future<void> cancelSubscription() async {
    final prefs = await SharedPreferences.getInstance();
    final tierKey = await _getTierKey();
    final expiryKey = await _getExpiryKey();
    final purchaseDateKey = await _getPurchaseDateKey();

    await prefs.setInt(tierKey, 0);
    await prefs.remove(expiryKey);
    await prefs.remove(purchaseDateKey);

    final userId = await _getUserId();
    print('‚úÖ Subscription cancelled for user: $userId');

    // Sync cancellation to cloud
    await _syncToSupabase();
  }

  // ------------------------- CLOUD SYNC METHODS -------------------------

  // Sync subscription to Supabase (cloud storage)
  static Future<void> _syncToSupabase() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final supabaseUrl = prefs.getString('supabase_url');
      final supabaseKey = prefs.getString('supabase_anon_key');

      if (supabaseUrl == null || supabaseKey == null) {
        print('‚ö†Ô∏è Supabase not configured. Subscription saved locally only.');
        return;
      }

      final userId = await _getUserId();
      final tierKey = await _getTierKey();
      final expiryKey = await _getExpiryKey();
      final purchaseDateKey = await _getPurchaseDateKey();

      final tierIndex = prefs.getInt(tierKey) ?? 0;
      final expiryString = prefs.getString(expiryKey);
      final purchaseString = prefs.getString(purchaseDateKey);

      final subscriptionData = {
        'user_id': userId,
        'tier_index': tierIndex,
        'tier_name': SubscriptionTier.values[tierIndex]
            .toString()
            .split('.')
            .last,
        'expiry_date': expiryString,
        'purchase_date': purchaseString,
        'updated_at': DateTime.now().toIso8601String(),
      };

      // Insert to Supabase (creates new record for each purchase/renewal)
      final response = await http.post(
        Uri.parse('$supabaseUrl/rest/v1/subscriptions'),
        headers: {
          'apikey': supabaseKey,
          'Authorization': 'Bearer $supabaseKey',
          'Content-Type': 'application/json',
          'Prefer': 'return=minimal',
        },
        body: jsonEncode(subscriptionData),
      );

      if (response.statusCode == 201 || response.statusCode == 200) {
        print('‚òÅÔ∏è  Subscription synced to cloud');
        print('   User: $userId');
        print(
          '   Tier: ${SubscriptionTier.values[tierIndex].toString().split('.').last}',
        );
      } else {
        print('‚ö†Ô∏è  Failed to sync subscription: ${response.statusCode}');
        print('   ${response.body}');
      }
    } catch (e) {
      print('‚ö†Ô∏è  Cloud sync error: $e');
      // Don't throw - local storage still works
    }
  }

  // Load subscription from Supabase (called on app start or login)
  static Future<bool> syncFromSupabase() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final supabaseUrl = prefs.getString('supabase_url');
      final supabaseKey = prefs.getString('supabase_anon_key');

      if (supabaseUrl == null || supabaseKey == null) {
        print('‚ö†Ô∏è Supabase not configured. Using local subscription data.');
        return false;
      }

      final userId = await _getUserId();

      print('‚òÅÔ∏è  Loading subscription from cloud...');

      // Fetch user's latest subscription from Supabase (most recent first)
      final response = await http.get(
        Uri.parse(
          '$supabaseUrl/rest/v1/subscriptions?user_id=eq.$userId&select=*&order=created_at.desc&limit=1',
        ),
        headers: {
          'apikey': supabaseKey,
          'Authorization': 'Bearer $supabaseKey',
        },
      );

      if (response.statusCode == 200) {
        final List<dynamic> data = jsonDecode(response.body);

        if (data.isEmpty) {
          print('   No cloud subscription found for user');
          return false;
        }

        // Get the most recent subscription
        final subscription = data[0];
        final tierIndex = subscription['tier_index'] as int;
        final expiryString = subscription['expiry_date'] as String?;
        final purchaseString = subscription['purchase_date'] as String?;

        if (expiryString != null) {
          final expiryDate = DateTime.parse(expiryString);

          // Only sync if not expired
          if (DateTime.now().isBefore(expiryDate)) {
            final tierKey = await _getTierKey();
            final expiryKey = await _getExpiryKey();
            final purchaseDateKey = await _getPurchaseDateKey();

            await prefs.setInt(tierKey, tierIndex);
            await prefs.setString(expiryKey, expiryString);
            if (purchaseString != null) {
              await prefs.setString(purchaseDateKey, purchaseString);
            }

            print('‚úÖ Subscription loaded from cloud');
            print(
              '   Tier: ${SubscriptionTier.values[tierIndex].toString().split('.').last}',
            );
            print('   Expires: ${expiryDate.toString().split(' ')[0]}');
            return true;
          } else {
            print('   Cloud subscription expired');
            return false;
          }
        }
      } else {
        print('‚ö†Ô∏è  Failed to fetch subscription: ${response.statusCode}');
      }

      return false;
    } catch (e) {
      print('‚ö†Ô∏è  Failed to sync from cloud: $e');
      return false;
    }
  }

  // ------------------------- FEATURE ACCESS METHODS -------------------------

  // Check if today is Sunday (for free tier access)
  static bool isSunday() {
    return DateTime.now().weekday == DateTime.sunday;
  }

  // Check if user can access devotionals
  static Future<bool> canAccessDevotionals() async {
    final hasPremium = await hasPremiumAccess();
    if (hasPremium) return true;

    // Free users can only access on Sunday
    return isSunday();
  }

  // Check if user can download devotionals
  static Future<bool> canDownloadDevotionals() async {
    return await hasPremiumAccess();
  }

  // Check if user can access additional Bible translations
  static Future<bool> canAccessTranslation(String translationId) async {
    // ASV is always available for free users
    if (translationId.toLowerCase() == 'asv') return true;

    // Other translations require premium
    return await hasPremiumAccess();
  }

  // Get days remaining in subscription
  static Future<int> getDaysRemaining() async {
    final expiryDate = await getExpiryDate();
    if (expiryDate == null) return 0;

    final difference = expiryDate.difference(DateTime.now());
    return difference.inDays.clamp(0, 999);
  }
}

// ------------------------- PAYMENT PLANS PAGE -------------------------

class EnhancedPaymentPlansPage extends StatefulWidget {
  const EnhancedPaymentPlansPage({super.key});

  @override
  State<EnhancedPaymentPlansPage> createState() =>
      _EnhancedPaymentPlansPageState();
}

class _EnhancedPaymentPlansPageState extends State<EnhancedPaymentPlansPage> {
  SubscriptionTier? currentTier;
  DateTime? expiryDate;
  bool isLoading = true;
  Currency userCurrency = Currency.NGN; // Default currency

  @override
  void initState() {
    super.initState();
    _loadSubscriptionStatus();
    _detectCurrency();
  }

  // Detect user's currency
  Future<void> _detectCurrency() async {
    try {
      final currency = await CurrencyManager.getCurrentCurrency();
      setState(() {
        userCurrency = currency;
      });
    } catch (e) {
      print('Error detecting currency: $e');
      // Keep default NGN
    }
  }

  Future<void> _loadSubscriptionStatus() async {
    setState(() => isLoading = true);

    try {
      final tier = await SubscriptionManager.getCurrentTier();
      final expiry = await SubscriptionManager.getExpiryDate();

      setState(() {
        currentTier = tier;
        expiryDate = expiry;
        isLoading = false;
      });
    } catch (e) {
      setState(() {
        currentTier = SubscriptionTier.free;
        isLoading = false;
      });
    }
  }

  Future<void> _selectPlan(SubscriptionPlan plan) async {
    if (plan.tier == SubscriptionTier.free) {
      // Check if user is already on free plan or wants to downgrade
      if (currentTier == SubscriptionTier.free) {
        _showInfoDialog('You are already on the free plan');
        return;
      } else {
        // User wants to downgrade from premium to free
        _showInfoDialog(
          'To cancel your premium subscription, please contact support',
        );
        return;
      }
    }

    // Show plan confirmation with proper context handling
    final confirmed = await showDialog<bool>(
      context: context,
      barrierDismissible: true, // ‚úÖ Allow dismissing by tapping outside
      builder: (BuildContext dialogContext) {
        // ‚úÖ Use separate dialog context
        return AlertDialog(
          backgroundColor: const Color(0xFF1E1E1E),
          title: Text(
            'Upgrade to ${plan.name}',
            style: const TextStyle(color: Colors.white),
          ),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'You are about to purchase:',
                style: TextStyle(color: Colors.white70, fontSize: 14),
              ),
              const SizedBox(height: 16),
              Container(
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  color: Colors.amber.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(12),
                  border: Border.all(color: Colors.amber.withOpacity(0.3)),
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      plan.name,
                      style: const TextStyle(
                        color: Colors.amber,
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 8),
                    Text(
                      '${plan.getPriceDisplay(userCurrency)} for ${plan.durationDisplay}',
                      style: const TextStyle(color: Colors.white70),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      '${userCurrency.symbol}${plan.getPricePerMonth(userCurrency).toStringAsFixed(userCurrency == Currency.NGN || userCurrency == Currency.GHS || userCurrency == Currency.KES || userCurrency == Currency.ZAR ? 0 : 2)}/month',
                      style: const TextStyle(color: Colors.green, fontSize: 12),
                    ),
                  ],
                ),
              ),
              const SizedBox(height: 16),
              const Text(
                'You will get access to:',
                style: TextStyle(color: Colors.white70, fontSize: 12),
              ),
              const SizedBox(height: 8),
              ...plan.features.map(
                (feature) => Padding(
                  padding: const EdgeInsets.only(bottom: 4),
                  child: Text(
                    feature,
                    style: const TextStyle(color: Colors.green, fontSize: 12),
                  ),
                ),
              ),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () =>
                  Navigator.pop(dialogContext, false), // ‚úÖ Use dialogContext
              child: const Text('Cancel', style: TextStyle(color: Colors.grey)),
            ),
            ElevatedButton(
              onPressed: () =>
                  Navigator.pop(dialogContext, true), // ‚úÖ Use dialogContext
              style: ElevatedButton.styleFrom(backgroundColor: Colors.amber),
              child: Text(
                'Purchase ${plan.getPriceDisplay(userCurrency)}',
                style: const TextStyle(color: Colors.black),
              ),
            ),
          ],
        );
      },
    );

    if (confirmed == true) {
      // Simulate payment processing
      await _processPurchase(plan);
    }
  }

  Future<void> _processPurchase(SubscriptionPlan plan) async {
    try {
      // Get the price in the user's currency
      final amount = plan.getPrice(userCurrency);

      // Initiate Paystack payment directly (Paystack shows its own loading UI)
      final paymentResponse = await PaystackService.instance.initiatePayment(
        context: context,
        amount: amount,
        planName: plan.name,
        planId: plan.tier.toString(),
        currency: userCurrency.code, // Pass currency code to Paystack
      );

      // Check payment response
      if (paymentResponse != null && paymentResponse.isSuccessful) {
        // Payment successful - activate subscription
        await SubscriptionManager.activateSubscription(plan);

        // Save payment record with user profile link
        await PaystackService.instance.savePaymentRecord(
          transactionId: paymentResponse.transactionId,
          txRef: paymentResponse.txRef,
          amount: paymentResponse.amount,
          planId: plan.tier.toString(),
          planName: plan.name,
          planDurationMonths: plan.durationMonths,
          status: 'successful',
        );

        // Reload status
        await _loadSubscriptionStatus();

        // Small delay to ensure UI is ready after auto-redirect
        await Future.delayed(const Duration(milliseconds: 300));

        // Show success message
        if (mounted) {
          showDialog(
            context: context,
            barrierDismissible: false,
            builder: (context) => AlertDialog(
              backgroundColor: const Color(0xFF1E1E1E),
              title: Row(
                children: [
                  const Icon(Icons.check_circle, color: Colors.green, size: 32),
                  const SizedBox(width: 12),
                  const Text(
                    'Payment Successful!',
                    style: TextStyle(color: Colors.white),
                  ),
                ],
              ),
              content: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'You have successfully upgraded to ${plan.name}!',
                    style: const TextStyle(color: Colors.white70),
                  ),
                  const SizedBox(height: 16),
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: Colors.green.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        const Text(
                          'Your premium features are now active:',
                          style: TextStyle(
                            color: Colors.green,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        const SizedBox(height: 8),
                        ...plan.features.map(
                          (feature) => Padding(
                            padding: const EdgeInsets.only(bottom: 4),
                            child: Text(
                              feature,
                              style: const TextStyle(
                                color: Colors.white70,
                                fontSize: 12,
                              ),
                            ),
                          ),
                        ),
                        const SizedBox(height: 12),
                        const Divider(color: Colors.white24),
                        const SizedBox(height: 8),
                        Text(
                          'Transaction ID: ${paymentResponse.transactionId}',
                          style: const TextStyle(
                            color: Colors.white54,
                            fontSize: 10,
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
              actions: [
                ElevatedButton(
                  onPressed: () => Navigator.pop(context),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.amber,
                  ),
                  child: const Text(
                    'Great!',
                    style: TextStyle(color: Colors.black),
                  ),
                ),
              ],
            ),
          );
        }
      } else if (paymentResponse != null && paymentResponse.isCancelled) {
        // Payment cancelled by user - save to transaction history
        await PaystackService.instance.savePaymentRecord(
          transactionId: paymentResponse.transactionId.isNotEmpty
              ? paymentResponse.transactionId
              : 'CANCELLED_${DateTime.now().millisecondsSinceEpoch}',
          txRef: paymentResponse.txRef.isNotEmpty
              ? paymentResponse.txRef
              : 'CANCELLED_${DateTime.now().millisecondsSinceEpoch}',
          amount: paymentResponse.amount,
          planId: plan.tier.toString(),
          planName: plan.name,
          planDurationMonths: plan.durationMonths,
          status: 'cancelled',
        );

        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Payment cancelled'),
              backgroundColor: Colors.orange,
            ),
          );
        }
      } else {
        // Payment failed - save to transaction history
        if (paymentResponse != null) {
          await PaystackService.instance.savePaymentRecord(
            transactionId: paymentResponse.transactionId.isNotEmpty
                ? paymentResponse.transactionId
                : 'FAILED_${DateTime.now().millisecondsSinceEpoch}',
            txRef: paymentResponse.txRef.isNotEmpty
                ? paymentResponse.txRef
                : 'FAILED_${DateTime.now().millisecondsSinceEpoch}',
            amount: paymentResponse.amount,
            planId: plan.tier.toString(),
            planName: plan.name,
            planDurationMonths: plan.durationMonths,
            status: 'failed',
          );
        }

        final errorMessage =
            paymentResponse?.message ?? 'Payment failed. Please try again.';
        if (mounted) {
          showDialog(
            context: context,
            builder: (context) => AlertDialog(
              backgroundColor: const Color(0xFF1E1E1E),
              title: Row(
                children: [
                  const Icon(Icons.error, color: Colors.red, size: 32),
                  const SizedBox(width: 12),
                  const Text(
                    'Payment Failed',
                    style: TextStyle(color: Colors.white),
                  ),
                ],
              ),
              content: Text(
                errorMessage,
                style: const TextStyle(color: Colors.white70),
              ),
              actions: [
                TextButton(
                  onPressed: () => Navigator.pop(context),
                  child: const Text(
                    'OK',
                    style: TextStyle(color: Colors.amber),
                  ),
                ),
                ElevatedButton(
                  onPressed: () {
                    Navigator.pop(context);
                    _processPurchase(plan); // Retry payment
                  },
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.amber,
                  ),
                  child: const Text(
                    'Try Again',
                    style: TextStyle(color: Colors.black),
                  ),
                ),
              ],
            ),
          );
        }
      }
    } catch (e) {
      // Handle errors
      if (mounted) {
        // Close any open dialogs
        Navigator.of(context).popUntil((route) => route.isFirst);

        showDialog(
          context: context,
          builder: (context) => AlertDialog(
            backgroundColor: const Color(0xFF1E1E1E),
            title: const Text('Error', style: TextStyle(color: Colors.white)),
            content: Text(
              'An error occurred: ${e.toString()}',
              style: const TextStyle(color: Colors.white70),
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(context),
                child: const Text('OK', style: TextStyle(color: Colors.amber)),
              ),
            ],
          ),
        );
      }
    }
  }

  void _showInfoDialog(String message) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: const Color(0xFF1E1E1E),
        title: const Text('Info', style: TextStyle(color: Colors.white)),
        content: Text(message, style: const TextStyle(color: Colors.white70)),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('OK', style: TextStyle(color: Colors.amber)),
          ),
        ],
      ),
    );
  }

  Future<void> _manageSub() async {
    if (currentTier == SubscriptionTier.free) {
      _showInfoDialog(
        'You are currently on the free plan. Select a premium plan above to upgrade.',
      );
      return;
    }

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: const Color(0xFF1E1E1E),
        title: const Text(
          'Manage Subscription',
          style: TextStyle(color: Colors.white),
        ),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Current Plan:',
              style: TextStyle(color: Colors.white70, fontSize: 12),
            ),
            const SizedBox(height: 8),
            Text(
              SubscriptionPlan.allPlans
                  .firstWhere((p) => p.tier == currentTier)
                  .name,
              style: const TextStyle(
                color: Colors.amber,
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            if (expiryDate != null) ...[
              const SizedBox(height: 16),
              Text(
                'Expires: ${DateFormat('MMM dd, yyyy').format(expiryDate!)}',
                style: const TextStyle(color: Colors.white70, fontSize: 14),
              ),
              const SizedBox(height: 4),
              FutureBuilder<int>(
                future: SubscriptionManager.getDaysRemaining(),
                builder: (context, snapshot) {
                  if (!snapshot.hasData) return const SizedBox();
                  return Text(
                    '${snapshot.data} days remaining',
                    style: const TextStyle(color: Colors.green, fontSize: 12),
                  );
                },
              ),
            ],
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Close', style: TextStyle(color: Colors.grey)),
          ),
          ElevatedButton(
            onPressed: () async {
              final navigator = Navigator.of(context);
              final messenger = ScaffoldMessenger.of(context);

              navigator.pop();
              final confirm = await showDialog<bool>(
                context: context,
                builder: (context) => AlertDialog(
                  backgroundColor: const Color(0xFF1E1E1E),
                  title: const Text(
                    'Cancel Subscription',
                    style: TextStyle(color: Colors.white),
                  ),
                  content: const Text(
                    'Are you sure you want to cancel your subscription? You will lose access to premium features.',
                    style: TextStyle(color: Colors.white70),
                  ),
                  actions: [
                    TextButton(
                      onPressed: () => Navigator.pop(context, false),
                      child: const Text(
                        'No, Keep It',
                        style: TextStyle(color: Colors.grey),
                      ),
                    ),
                    ElevatedButton(
                      onPressed: () => Navigator.pop(context, true),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.red,
                      ),
                      child: const Text(
                        'Yes, Cancel',
                        style: TextStyle(color: Colors.white),
                      ),
                    ),
                  ],
                ),
              );

              if (confirm == true) {
                await SubscriptionManager.cancelSubscription();
                await _loadSubscriptionStatus();
                if (mounted) {
                  messenger.showSnackBar(
                    const SnackBar(
                      content: Text('Subscription cancelled'),
                      backgroundColor: Colors.red,
                    ),
                  );
                }
              }
            },
            style: ElevatedButton.styleFrom(backgroundColor: Colors.red),
            child: const Text(
              'Cancel Subscription',
              style: TextStyle(color: Colors.white),
            ),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    if (isLoading) {
      return const Scaffold(
        backgroundColor: Color(0xFF1E1E1E),
        body: Center(child: CircularProgressIndicator(color: Colors.amber)),
      );
    }

    return Scaffold(
      appBar: AppBar(
        title: const Text("üí≥ Subscription Plans"),
        backgroundColor: Colors.black,
        actions: [
          if (currentTier != SubscriptionTier.free)
            IconButton(
              icon: const Icon(Icons.settings),
              onPressed: _manageSub,
              tooltip: 'Manage Subscription',
            ),
        ],
      ),
      backgroundColor: const Color(0xFF1E1E1E),
      body: SingleChildScrollView(
        child: Column(
          children: [
            // Current Status Banner
            _buildStatusBanner(),

            const SizedBox(height: 24),

            // Plans List
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text(
                    'Choose Your Plan',
                    style: TextStyle(
                      color: Colors.white,
                      fontSize: 24,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 8),
                  const Text(
                    'Unlock premium features and support our mission',
                    style: TextStyle(color: Colors.white70),
                  ),
                  const SizedBox(height: 24),

                  ...SubscriptionPlan.allPlans.map((plan) {
                    return Padding(
                      padding: const EdgeInsets.only(bottom: 16),
                      child: _buildPlanCard(plan),
                    );
                  }),
                ],
              ),
            ),

            const SizedBox(height: 24),

            // FAQ Section
            _buildFAQSection(),

            const SizedBox(height: 24),
          ],
        ),
      ),
    );
  }

  Widget _buildStatusBanner() {
    final isFreeTier = currentTier == SubscriptionTier.free;
    final isPremium = !isFreeTier;

    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(20),
      decoration: BoxDecoration(
        gradient: LinearGradient(
          colors: isFreeTier
              ? [Colors.grey[800]!, Colors.grey[900]!]
              : [Colors.amber[700]!, Colors.amber[900]!],
        ),
      ),
      child: Column(
        children: [
          Icon(
            isPremium ? Icons.workspace_premium : Icons.person,
            size: 48,
            color: Colors.white,
          ),
          const SizedBox(height: 12),
          Text(
            isPremium ? 'Premium Member' : 'Free Member',
            style: const TextStyle(
              color: Colors.white,
              fontSize: 24,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          if (isPremium && expiryDate != null) ...[
            Text(
              'Active until ${DateFormat('MMM dd, yyyy').format(expiryDate!)}',
              style: const TextStyle(color: Colors.white70),
            ),
            const SizedBox(height: 4),
            FutureBuilder<int>(
              future: SubscriptionManager.getDaysRemaining(),
              builder: (context, snapshot) {
                if (!snapshot.hasData) return const SizedBox();
                return Text(
                  '${snapshot.data} days remaining',
                  style: const TextStyle(
                    color: Colors.white,
                    fontWeight: FontWeight.bold,
                  ),
                );
              },
            ),
          ] else ...[
            const Text(
              'Limited access to devotionals',
              style: TextStyle(color: Colors.white70),
            ),
            const SizedBox(height: 4),
            FutureBuilder<bool>(
              future: SubscriptionManager.canAccessDevotionals(),
              builder: (context, snapshot) {
                if (!snapshot.hasData) return const SizedBox();
                return Container(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 12,
                    vertical: 6,
                  ),
                  decoration: BoxDecoration(
                    color: snapshot.data! ? Colors.green : Colors.red,
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Text(
                    snapshot.data!
                        ? '‚úÖ Today is Sunday - Access granted!'
                        : 'üîí Devotionals available on Sunday only',
                    style: const TextStyle(
                      color: Colors.white,
                      fontSize: 12,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                );
              },
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildPlanCard(SubscriptionPlan plan) {
    final isCurrentPlan = plan.tier == currentTier;
    final isBestValue = plan.tier == SubscriptionTier.sixMonths;
    final isPremiumPlan = plan.tier != SubscriptionTier.free;

    return GestureDetector(
      onTap: isCurrentPlan ? null : () => _selectPlan(plan),
      child: Stack(
        clipBehavior: Clip.none,
        children: [
          Container(
            width: double.infinity,
            padding: const EdgeInsets.all(20),
            decoration: BoxDecoration(
              color: const Color(0xFF2D2D2D),
              borderRadius: BorderRadius.circular(16),
              border: Border.all(
                color: isCurrentPlan
                    ? Colors.amber
                    : isBestValue
                    ? Colors.green
                    : Colors.white24,
                width: isCurrentPlan || isBestValue ? 2 : 1,
              ),
              boxShadow: isCurrentPlan || isBestValue
                  ? [
                      BoxShadow(
                        color: (isCurrentPlan ? Colors.amber : Colors.green)
                            .withOpacity(0.3),
                        blurRadius: 12,
                        spreadRadius: 2,
                      ),
                    ]
                  : null,
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Plan Header
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          plan.name,
                          style: TextStyle(
                            color: isCurrentPlan ? Colors.amber : Colors.white,
                            fontSize: 22,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        const SizedBox(height: 4),
                        Text(
                          plan.durationDisplay,
                          style: TextStyle(
                            color: isCurrentPlan
                                ? Colors.amber[300]
                                : Colors.white70,
                            fontSize: 14,
                          ),
                        ),
                      ],
                    ),
                    Column(
                      crossAxisAlignment: CrossAxisAlignment.end,
                      children: [
                        Text(
                          plan.getPriceDisplay(userCurrency),
                          style: TextStyle(
                            color: isCurrentPlan ? Colors.amber : Colors.white,
                            fontSize: 32,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        if (isPremiumPlan)
                          Text(
                            '${userCurrency.symbol}${plan.getPricePerMonth(userCurrency).toStringAsFixed(userCurrency == Currency.NGN || userCurrency == Currency.GHS || userCurrency == Currency.KES || userCurrency == Currency.ZAR ? 0 : 2)}/mo',
                            style: const TextStyle(
                              color: Colors.green,
                              fontSize: 12,
                            ),
                          ),
                      ],
                    ),
                  ],
                ),

                const SizedBox(height: 20),

                // Features
                ...plan.features.map(
                  (feature) => Padding(
                    padding: const EdgeInsets.only(bottom: 8),
                    child: Row(
                      children: [
                        const Icon(
                          Icons.check_circle,
                          color: Colors.green,
                          size: 18,
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Text(
                            feature,
                            style: const TextStyle(
                              color: Colors.white,
                              fontSize: 14,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                ),

                // Limitations (for free plan)
                if (plan.limitations.isNotEmpty) ...[
                  const SizedBox(height: 12),
                  const Divider(color: Colors.white24),
                  const SizedBox(height: 12),
                  ...plan.limitations.map(
                    (limitation) => Padding(
                      padding: const EdgeInsets.only(bottom: 8),
                      child: Text(
                        limitation,
                        style: const TextStyle(color: Colors.red, fontSize: 12),
                      ),
                    ),
                  ),
                ],

                const SizedBox(height: 20),

                // Action Button
                SizedBox(
                  width: double.infinity,
                  child: ElevatedButton(
                    onPressed: isCurrentPlan ? null : () => _selectPlan(plan),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: isCurrentPlan
                          ? Colors.grey[700]
                          : Colors.amber,
                      foregroundColor: isCurrentPlan
                          ? Colors.white
                          : Colors.black,
                      padding: const EdgeInsets.symmetric(vertical: 14),
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(12),
                      ),
                    ),
                    child: Text(
                      isCurrentPlan
                          ? 'Current Plan'
                          : plan.tier == SubscriptionTier.free
                          ? 'Free Forever'
                          : 'Select Plan',
                      style: const TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),

          // Best Value Badge
          if (isBestValue)
            Positioned(
              top: -12,
              right: 20,
              child: Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: 16,
                  vertical: 6,
                ),
                decoration: BoxDecoration(
                  color: Colors.green,
                  borderRadius: BorderRadius.circular(20),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.green.withOpacity(0.5),
                      blurRadius: 8,
                      spreadRadius: 1,
                    ),
                  ],
                ),
                child: const Text(
                  'üíé BEST VALUE',
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: 12,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ),

          // Current Plan Badge
          if (isCurrentPlan)
            Positioned(
              top: -12,
              left: 20,
              child: Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: 16,
                  vertical: 6,
                ),
                decoration: BoxDecoration(
                  color: Colors.amber,
                  borderRadius: BorderRadius.circular(20),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.amber.withOpacity(0.5),
                      blurRadius: 8,
                      spreadRadius: 1,
                    ),
                  ],
                ),
                child: const Text(
                  '‚ú® ACTIVE',
                  style: TextStyle(
                    color: Colors.black,
                    fontSize: 12,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ),
        ],
      ),
    );
  }

  Widget _buildFAQSection() {
    return Container(
      padding: const EdgeInsets.all(20),
      margin: const EdgeInsets.symmetric(horizontal: 16),
      decoration: BoxDecoration(
        color: const Color(0xFF2D2D2D),
        borderRadius: BorderRadius.circular(16),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Row(
            children: [
              Icon(Icons.help_outline, color: Colors.amber),
              SizedBox(width: 8),
              Text(
                'Frequently Asked Questions',
                style: TextStyle(
                  color: Colors.white,
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ],
          ),
          const SizedBox(height: 16),
          _buildFAQItem(
            'Can I change my plan later?',
            'Yes! You can upgrade or downgrade your plan at any time.',
          ),
          _buildFAQItem(
            'What happens when my subscription expires?',
            'You will automatically revert to the free plan with limited access.',
          ),
          _buildFAQItem(
            'Are payments secure?',
            'Yes, all payments are processed securely through our payment provider.',
          ),
          _buildFAQItem(
            'Can I get a refund?',
            'Refunds are available within 7 days of purchase. Contact support for assistance.',
          ),
        ],
      ),
    );
  }

  Widget _buildFAQItem(String question, String answer) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            question,
            style: const TextStyle(
              color: Colors.amber,
              fontSize: 14,
              fontWeight: FontWeight.w600,
            ),
          ),
          const SizedBox(height: 4),
          Text(
            answer,
            style: const TextStyle(
              color: Colors.white70,
              fontSize: 13,
              height: 1.4,
            ),
          ),
        ],
      ),
    );
  }
}
